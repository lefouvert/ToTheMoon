use { Vessel, VesselSituation, AutopilotMode, Part, DeployableDeployState } from ksp::vessel
use { current_time, wait_until, yield, sleep } from ksp::game
use { ResourceData } from ksp::resource
use { Direction, Vec3, vec3, vec2, TransformFrame, euler, GlobalVector, look_dir_up } from ksp::math
use { min, max, clamp, abs, MIN_FLOAT, log, clamp_degrees360 } from core::math
use { ExperimentState, Experiment, ResearchLocation, ResearchReport, ScienceSituation } from ksp::science
use { CONSOLE } from ksp::console

use { control_steering } from std::control::steering

use { ThrustSituation, ThrustSituationConst, MassState, MassStateConst, StagingCase, Throttle, Resource } from ship::constant
use { InsignificantAtmoshpere } from body::constant
use { Circle, Array } from math::constant
use { Stage } from ship::stage
use { atmosphere_depth } from body::atmosphere
use { deviation } from ship::navigation
use { earlyWeightConvex, Derivative, round_at, cartesian_to_polar, polar_to_cartesian, almost_equal_global } from math::tool
use { hms, engineeringNotation } from ui::unit

pub struct SmoothStop(target: float, timeToStop: float) {
    differential: Derivative = Derivative(0.01)
    lastThrottle: float = Throttle.Max
    timeToStop: float = timeToStop
    target: float = target
}

pub struct Ship(vessel: Vessel) {
    ship: Vessel = vessel
    current_stage : int = vessel.staging.current
    stages: Stage[] = (0..vessel.staging.count)
        .map(fn(s) -> Stage(vessel, s))
    launch_timeStamp: float = -current_time() // negative if prelaunch. positive at first ignition.
    //shorteners
    transform_frame : TransformFrame = vessel.control_frame
    prograde: fn() -> Direction = fn() -> vessel.orbit.prograde(current_time()).to_direction()
    retrograde: fn() -> Direction = fn() -> (-vessel.orbit.prograde(current_time())).to_direction()
    normal: fn() -> Direction = fn() -> vessel.orbit.normal_plus(current_time()).to_direction()
    antinormal: fn() -> Direction = fn() -> (-vessel.orbit.normal_plus(current_time())).to_direction()
    radial: fn() -> Direction = fn() -> vessel.orbit.radial_plus(current_time()).to_direction()
    antiradial: fn() -> Direction = fn() -> (-vessel.orbit.radial_plus(current_time())).to_direction()
    // up: Direction = vessel.global_up.to_local(control_frame).to_direction
    // north: Direction = vessel.global_north.to_local(control_frame).to_direction
    apoapsis: fn() -> float = fn() -> vessel.orbit.apoapsis|0
    periapsis: fn() -> float = fn() -> vessel.orbit.periapsis
    altitude: fn() -> float = fn() -> vessel.altitude_sealevel
    smoothStop: SmoothStop = SmoothStop(0.0, 0.0) // dummy 'altitude' and 'time to stop'
    // TODO partmonitor : print if i lost a part
}


impl Ship {

// ///////////////////////// TODO

// trash useless (fairing, empty tanks or stages) / check empty ?
// warpwait
// park
// dock
// suicideburn
// get/change control module ?

//////////////////////////////// ongoing
    sync fn throttle_direction(self, targetDir: Direction, deadzone: float = 0, tolerance: float = 1.0) -> float = {
        const assessedDeviation = max(deviation(targetDir, self.ship.facing) - deadzone, Circle.None)
        earlyWeightConvex(tolerance * assessedDeviation / Circle.Quarter)
    }

    sync fn throttle_temperature(self) -> float = {
        if(atmosphere_depth(self.ship.main_body) < self.ship.altitude_sealevel)
            return Throttle.Max
        const hotPart = self.ship.parts
            .sort_by(fn(p) -> p.temperature / p.max_temperature)
            .reverse()[0]
        const minTempFullThrust = 0.5
        const maxTempRatio = 0.9
        const slope = (
            ratio: (Throttle.Max - Throttle.Min) / (minTempFullThrust - maxTempRatio),
            yIntercept: -maxTempRatio * (Throttle.Max - Throttle.Min) / (minTempFullThrust - maxTempRatio)
        )
        clamp(slope.ratio * (hotPart.temperature / hotPart.max_temperature) + slope.yIntercept, Throttle.Min, Throttle.Max)
    }

    sync fn throttle_q(self) -> float = {
        const MAX_Q = 100.0

        const minQFullThrust = 0.5
        const maxQRatio = 0.9
        const slope = (
            ratio: (Throttle.Max - Throttle.Min) / (minQFullThrust - maxQRatio),
            yIntercept: -maxQRatio * (Throttle.Max - Throttle.Min) / (minQFullThrust - maxQRatio)
        )
        clamp(slope.ratio * (self.ship.dynamic_pressure_kpa / MAX_Q) + slope.yIntercept, Throttle.Min, Throttle.Max)
    }

    sync fn set_throttle_altitude(self, targetAltitude:float, timeToStop:float = 5) -> Unit =
        self.smoothStop = SmoothStop(targetAltitude, timeToStop)

    sync fn throttle_altitude(self, measure:float) -> float = { // TODO check why sometime it stop early
        if(abs(self.smoothStop.differential.lastResult) < MIN_FLOAT)
            return self.smoothStop.lastThrottle

        const timespan = clamp((self.smoothStop.target - measure) * self.smoothStop.timeToStop / (abs(self.smoothStop.differential.lastResult) * 100), 0.0, 1.0)
        if(current_time() - self.smoothStop.differential.lastTime < timespan)
            return self.smoothStop.lastThrottle

        const dMByDT = self.smoothStop.differential.compute(measure)
        if(abs(dMByDT) < MIN_FLOAT)
            return self.smoothStop.lastThrottle // TODO

        const commun_direction = self.ship.facing.vector.normalized.dot(self.prograde().vector.normalized)
        const deltaDirection =
            if(self.smoothStop.target < measure)
                (abs(dMByDT) * self.smoothStop.timeToStop) / commun_direction
            else
                commun_direction / (abs(dMByDT) * self.smoothStop.timeToStop)

        self.smoothStop.lastThrottle = clamp((self.smoothStop.target - measure) * deltaDirection, Throttle.Min, min(self.smoothStop.lastThrottle + 0.01, Throttle.Max))
        self.smoothStop.lastThrottle
    }

    fn is_maneuverable(self, verbose: bool = true) -> bool = {
        // TODO
        // if (!maneuverable && verbose) print("blabla cant move")
        return true
    }

    // fn align(self, direction : Direction, delta: float = 1.0) -> bool = { // in celectial frame
    fn align(self, pointToLook : Vec3, delta: float = 1.0) -> bool = { // in celectial frame
        if(!self.is_maneuverable())
            return false

        // Enable SAS
        self.ship.autopilot.enabled = true
        self.ship.autopilot.mode = AutopilotMode.Autopilot
        self.ship.autopilot.target_orientation = pointToLook

        // Wait for alignment
        while(self.ship.facing.vector.angle_to(pointToLook) > delta) yield()
        while(self.ship.angular_momentum.magnitude > delta) yield()

        self.ship.autopilot.mode = AutopilotMode.StabilityAssist
        true
    }

    fn park(self, rought: bool = false, verbose: bool = true) -> bool = {
        const vessel = self.ship
        const staticFrame = vessel.main_body.celestial_frame
        const accuracy = if(rought) 2 else 3

        if(verbose)
            self.print("Setting stationed attitude...")

        vessel.autopilot.enabled = true
        vessel.autopilot.mode = AutopilotMode.StabilityAssist
        wait_until(fn() -> round_at(vessel.angular_velocity.magnitude, accuracy) == 0)

        let referenceOrbit = vessel.orbit
        while(referenceOrbit.reference_body.parent_body.defined)
            referenceOrbit = referenceOrbit.reference_body.orbit

        const starExposure = (exposure: referenceOrbit.reference_body.global_position.to_local(staticFrame), normal: referenceOrbit.orbit_normal)
        const vesselExposure = ideal_exposure(vessel)

        const starDir = look_dir_up(starExposure.exposure.normalized, starExposure.normal.normalized)
        const vesselDir = look_dir_up(vesselExposure.exposure.to_global(vessel.control_frame).to_local(staticFrame), vesselExposure.normal.to_global(vessel.control_frame).to_local(staticFrame))

        const steering = control_steering(vessel)
        steering.set_direction(starDir * vesselDir.inverse * vessel.global_facing.to_local(staticFrame))

        wait_until(fn() ->
            round_at(vesselExposure.exposure.to_global(vessel.control_frame).normalized * starExposure.exposure.to_global(staticFrame).normalized, accuracy) == 1
            && round_at(vesselExposure.normal.to_global(vessel.control_frame).normalized * starExposure.normal.to_global(staticFrame).normalized, accuracy) == 1
            && round_at(vessel.angular_velocity.magnitude, accuracy) == 0
        )
        steering.release()
        vessel.autopilot.mode = AutopilotMode.StabilityAssist

        if(verbose)
            self.print("Stationed")

        true
    }

    fn dock(self, vessel: Vessel) -> bool = {
        // TODO
        return true
    }

    fn check_staging(self, verbose: bool = true) -> bool = {
        if(self.current_stage == 0)
            return false

        const stagingCase = [(
            need: (!self.stages[self.current_stage].ignited()) && self.stages[self.current_stage].has_engine() ,
            reason: "not ignited"
        ),(
            need: self.stages[self.current_stage].flameout() && self.stages[self.current_stage].has_engine() ,
            reason: "flameout"
        ),(
            need: self.stages[self.current_stage].empty() ,
            reason: "empty"
        )]

        if(stagingCase.exists(fn(c) -> c.need))
            return stage(self, stagingCase, verbose)

        stagingCase.exists(fn(c) -> c.need)
    }

    fn check_science(self, autoSend: bool = true, verbose: bool = true) -> Unit = {
        const vessel = self.ship
        const locationComparison = fn(locA: ResearchLocation, locB: ResearchLocation) -> {
            (locA.body_name == locB.body_name || locA.body_name.length == Array.Empty || locB.body_name.length == Array.Empty)
            && (locA.science_region == locB.science_region || (!locA.requires_region) || (!locB.requires_region))
            && (locA.science_situation == locB.science_situation || locA.science_situation == ScienceSituation.None || locB.science_situation == ScienceSituation.None)
        }
        const storedReports =
            if(vessel.science_storage.defined)
                vessel.science_storage.value.research_reports
            else
                <ResearchReport>[]

        if(Some(shipLocation) = vessel.research_location) {
            const newExperiments = vessel.parts
                .filter(fn(p) -> p.science_experiment.defined)
                .flat_map(fn(p) -> p.science_experiment.value.experiments
                    .filter(fn(e) -> e.current_experiment_state == ExperimentState.READY
                        && e.current_experiment_state != ExperimentState.ALREADYSTORED
                        && ((!e.experiment_location.defined) || (!locationComparison(e.experiment_location.value, shipLocation))))
                )//.flat_map(fn(e) -> e)
                // .filter(fn(e) -> !storedReports.exists(fn(r) -> r.definition.id == e.definition.id && (locationComparison(r.research_location, shipLocation)))) // To not research already known datascience.
            run_science(self, newExperiments, verbose)
        }
        if(autoSend)
            emmit_science(self, storedReports, verbose)
        // TODO check experiment paused
    }

    sync fn science_running(self) -> bool =
        self.ship.parts
            .filter(fn(p) -> p.science_experiment.defined)
            .exists(fn(p) -> p.science_experiment.value.experiments
                .exists(fn(e) -> e.current_experiment_state == ExperimentState.RUNNING)
            )

    sync fn available_power(self) -> float =
        self.ship.parts
            .flat_map(fn(p) -> p.resources.list.filter(fn(r) -> r.resource.id == Resource.EC))
            .reduce(0.0, fn(sum, r) -> sum + r.stored_units)


    fn check_deploy(self, force: bool = false, verbose: bool = true) -> Part[] = {
        const vessel = self.ship
        if(vessel.static_pressure_kpa > InsignificantAtmoshpere || vessel.dynamic_pressure_kpa > InsignificantAtmoshpere)
            return <Part>[]
        const toDeploy = vessel.parts
            .filter(fn(p) -> p.deployable.defined)
            .filter(fn(p) -> p.deployable.value.extendable
                && (if(!force) p.deployable.value.retractable else force)
                && p.deployable.value.deploy_state == DeployableDeployState.Retracted
                && (!p.heatshield.defined))
        self.deploy(toDeploy, verbose)
        toDeploy
    }

    fn deploy(self, toDeploy: Part[], verbose: bool = true) -> bool = {
        const vessel = self.ship
        const sectionVec = vessel.global_facing.to_local(vessel.control_frame).vector.cross(vessel.global_up.to_local(vessel.control_frame))
        const sortedDeploy = toDeploy
            .filter(fn(p) -> p.deployable.defined)
            .map(fn(p) -> (module: p.deployable.value, distance: abs(p.global_position.to_local(vessel.control_frame).dot(sectionVec))))
            .sort_by(fn(r) -> r.distance)

        for(r in sortedDeploy) {
            r.module.set_extended(true)
            if(verbose)
                self.print("Extending " + r.module.part_name)
            sleep(r.distance)
        }
        sortedDeploy.length > 0
    }

    sync fn is_deployed(self, toCheck: Part[]) -> bool =
        !toCheck
            .filter_map(fn(p) -> p.deployable)
            .exists(fn(m) -> !(m.extendable && m.deploy_state == DeployableDeployState.Extended))


    fn check_retract(self, verbose: bool = true) -> Part[] = {
        const vessel = self.ship
        const toRetract = vessel.parts
            .filter(fn(p) -> p.deployable.defined)
            .filter(fn(p) -> p.deployable.value.extendable && p.deployable.value.retractable && p.deployable.value.deploy_state == DeployableDeployState.Extended)
        self.retract(toRetract, verbose)
        toRetract
    }

    fn retract(self, toRetract: Part[], verbose: bool = true) -> bool = {
        const vessel = self.ship
        const sectionVec = vessel.global_facing.to_local(vessel.control_frame).vector.cross(vessel.global_up.to_local(vessel.control_frame))
        const sortedRetract = toRetract
            .map(fn(p) -> (module: p.deployable.value, distance: abs(p.global_position.to_local(vessel.control_frame).dot(sectionVec))))
            .sort_by(fn(r) -> r.distance)
            .reverse()

        for(r in sortedRetract) {
            r.module.set_extended(false)
            if(verbose)
                self.print("Retracting " + r.module.part_name)
            sleep(r.distance)
        }
        sortedRetract.length > 0
    }

    sync fn is_retracted(self, toCheck: Part[]) -> bool =
        !toCheck
            .filter_map(fn(p) -> p.deployable)
            .exists(fn(m) -> !(m.retractable && m.deploy_state == DeployableDeployState.Retracted))


    fn check_jettison(self, verbose: bool = true) -> Part[] = {
        const vessel = self.ship
        if(vessel.static_pressure_kpa > InsignificantAtmoshpere || vessel.dynamic_pressure_kpa > InsignificantAtmoshpere)
            return <Part>[]
        const toJettison = vessel.parts
            .filter(fn(p) -> p.fairing.defined && p.is_cargo_bay)
            .filter(fn(p) -> !p.fairing.value.is_jettisoned)
        self.jettison(toJettison, verbose)
        toJettison
    }

    fn jettison(self, toJettison: Part[], verbose: bool = true) -> bool = {
        const vessel = self.ship
        const sortedJettison = toJettison
            .filter(fn(p) -> p.fairing.defined)
            .map(fn(p) -> (module: p.fairing.value, height: vessel.global_facing.to_local(vessel.control_frame).vector.dot(p.global_position.to_local(vessel.control_frame))))
            .sort_by(fn(r) -> r.height)

        if (verbose) {
            for (r in sortedJettison)
                self.print("Jettisoning " + r.module.part_name)
        }

        if(sortedJettison.length == Array.Empty)
            return false

        sortedJettison
            .reduce(true, fn(checked, j) -> checked && j.module.jettison())
    }

    sync fn is_jettisoned(self, toCheck: Part[]) -> bool =
        !toCheck
            .filter_map(fn(p) -> p.fairing)
            .exists(fn(m) -> !m.is_jettisoned)

//////////////////////////////// ok


    sync fn update_stages(self, source: string = "Unknown") -> bool = {
        const vessel = self.ship
        if(self.ship.staging.count != self.stages.length) {
            // CONSOLE.print_line("## DEBUG ## Update tracking : " + source + " (count:" + self.ship.staging.count.to_string() + "|length:" + self.stages.length.to_string() + ")")
            self.stages = (0..vessel.staging.count)
                .map(fn(s) -> Stage(vessel, s))
            self.current_stage = self.stages.length - 1
        }
        true
    }

    fn drop(self) -> bool = {
        self.launch_timeStamp = current_time()
        const droped = !self.ship.parts
            .filter(fn(p) -> p.is_launch_clamp)
            .map(fn(p) -> p.launch_clamp.value.release())
            .exists(fn(r) -> !r)
        self.update_stages("ship drop")
        droped
    } // TODO YAGNI


    sync fn firstThrustStage(self) -> Option<int> = {
        self.update_stages("firstThrustStage")
        const thrustStages = self.stages
            .filter(fn(s) -> s.has_engine())
            .sort_by(fn(s) -> s.activation_number)
            .reverse()
        if (thrustStages.length > 0) thrustStages[0].activation_number else None()
    }

    sync fn throttle_current(self) -> float = {
        if(!self.firstThrustStage().defined)
            return Throttle.Min
        self.ship.engines
            .sort_by(fn(e) -> e.current_throttle)
            .reverse()[0].current_throttle
    }

    sync fn thrust(self, context: ThrustSituationConst = ThrustSituation.Current) -> float =
        self.stages[self.ship.staging.current].thrust(context)


    sync fn isp(self, context: ThrustSituationConst = ThrustSituation.CurrentAsOn) -> float =
        self.stages[self.ship.staging.current].isp(context)

    sync fn burntime(self) -> float =
        self.stages.reduce(0.0, fn(sum, s) -> sum + s.burntime())


    sync fn deltaV(self, context: ThrustSituationConst = ThrustSituation.Max_Vac) -> float =
        self.stages.reduce(0.0, fn(sum, s) -> sum + s.deltaV(context))


    sync fn twr(self, thrustContext: ThrustSituationConst = ThrustSituation.CurrentAsOn, massContext: MassStateConst = MassState.Total ) -> float =
        self.stages[self.ship.staging.current].twr(thrustContext, massContext)


    fn mass(self, context : MassStateConst = MassState.Total) -> float =
        self.ship.parts
            .filter(fn(p) -> !p.is_launch_clamp)
            .reduce(0.0, fn(mass, p) -> if (context == MassState.Total) mass + p.total_mass else mass + p.dry_mass)

    sync fn height(self) -> float = {
        const upVec = self.ship.up.normalized
        const partsPosition = self.ship.parts
            .map(fn(p) -> p.position.dot(upVec))
            .sort()
        partsPosition[partsPosition.length - 1] - partsPosition[Array.First]
    }

    fn print(self, message: string, multiline: bool = false) -> Unit = {
        const timestamp = hms(current_time() - abs(self.launch_timeStamp))
        const head = (if(self.launch_timeStamp < 0.0) "_" else "t")
        + "+" // (if(timestamp.positive) "+" else "-")
        + timestamp.hour.to_string() + "h"
        + timestamp.minute.to_string().pad_left("00".length).replace(" ", "0") + "m"
        + timestamp.second.to_fixed(2).pad_left("00.00".length).replace(" ", "0") + "s"
        + ": "
        if (multiline) {
            const tab = (0..head.length)
                .reduce("", fn(t, c) -> t + " ")
            CONSOLE.print_line(tab + message)
        }
        else
            CONSOLE.print_line(head + message)
    }

    fn print_status(self) -> Unit = {
        if(self.ship.situation == VesselSituation.PreLaunch) {
            self.print(self.ship.name + " is waiting for lift off on " + self.ship.main_body.name)
        }
        else if(self.ship.situation == VesselSituation.Flying) {
            self.print(self.ship.name + " is flying over " + self.ship.main_body.name)
            self.print("at an altitude of " + engineeringNotation(self.ship.altitude_sealevel, 5) + "m.", true)
        }
        else if(self.ship.situation == VesselSituation.SubOrbital) {
            self.print(engineeringNotation(self.ship.orbit.apoapsis|0.0, 4) + "m. suborbit above " + self.ship.main_body.name + " reach")
            self.print("with an inclination of " + self.ship.orbit.inclination.to_fixed(2) + "°", true)
        }
        else if(self.ship.situation == VesselSituation.Orbiting) {
            self.print(engineeringNotation(self.ship.orbit.periapsis, 4) + "m. | " + engineeringNotation(self.ship.orbit.apoapsis|0.0, 4) + "m. orbit above " + self.ship.main_body.name + " reach")
            self.print("with an inclination of " + self.ship.orbit.inclination.to_fixed(2) + "°", true)
            self.print("and an argument of periapsis of " + self.ship.orbit.argument_of_periapsis.to_fixed(2) + "°", true)
        }
        else if(self.ship.situation == VesselSituation.Escaping) {

        }
        else if(self.ship.situation == VesselSituation.Landed) {
            self.print(self.ship.name + " is landed on " + self.ship.main_body.name)
        }
        else if(self.ship.situation == VesselSituation.Splashed) {
            self.print(self.ship.name + " is splashed on " + self.ship.main_body.name)
        }
        else {
            self.print(self.ship.name + " status unknown.")
        }
    }
}

fn stage(ship: Ship, trigger: (need: bool, reason: string)[], verbose: bool) -> bool = {
    const vessel = ship.ship
    const oldStage = vessel.staging.current
    const reason = trigger
        .filter(fn(c) -> c.need)
        .reduce("", fn(agg, c) -> agg + (if(agg.length > 0) "|" else "") + c.reason)
    if(verbose) ship.print("(" + reason + ") -> Preparing to stage...")

    if(atmosphere_depth(vessel.main_body) > vessel.altitude_sealevel
    && vessel.situation != VesselSituation.Landed
    && vessel.situation != VesselSituation.Splashed
    && vessel.situation != VesselSituation.PreLaunch)
        ship.align(vessel.surface_velocity, 5)

    wait_until(fn() -> vessel.staging.ready)
    vessel.staging.next()
    wait_until(fn() -> vessel.staging.ready)

    if(vessel.dynamic_pressure_kpa > 1)
        sleep(1.0)

    if(trigger[StagingCase.NOT_IGN].need)
        wait_until(fn() -> ship.stages[ship.current_stage].ignited())

    wait_until(fn() -> ship.update_stages("check_stage"))
    if(verbose)
        ship.print("STAGING (" + (oldStage).to_string() + " -> " + ship.current_stage.to_string() + ").")
    ship.check_staging(verbose)
}


fn run_science(thisShip: Ship, experiments: Experiment[], verbose: bool = true) -> bool = {
    if(Some(shipLocation) = thisShip.ship.research_location) {
        if(verbose) {
            for (e in experiments)
                thisShip.print("Starting " + e.definition.id + " at " + shipLocation.body_name + "/" + shipLocation.science_situation.to_string() + "/" + shipLocation.science_region)
        }
        return experiments
            .map(fn(e) -> e.run_experiment())
            .exists(fn(done) -> done)
    }
    false
}

fn emmit_science(thisShip: Ship, reports: ResearchReport[], verbose: bool = true) -> bool = {
    const toSendReports = reports
        .filter(fn(r) -> r.transmission_percentage == 0.0 && r.transmission_size > 0.0 && (!r.transmission_status))
        .reduce((reports: <ResearchReport>[], consumption: 0.0), fn(agg, r) -> if(agg.consumption + r.ec_required < thisShip.available_power()) (reports: agg.reports + r, consumption: agg.consumption + r.ec_required) else (reports: agg.reports, consumption: agg.consumption))
    if(verbose) {
        for (r in toSendReports.reports)
                thisShip.print("Emitting " + r.definition.id + " from " + r.research_location.body_name + "/" + r.research_location.science_situation.to_string() + "/" + r.research_location.science_region)
    }
    toSendReports.reports
        .map(fn(r) -> r.start_transmit())
        .exists(fn(done) -> done)
}

// record of :
// vector going from command module to theorical ideal sun direction. Magnitude is expected EC output not considering blocking bodies or parts, or Star ratio/distance.
// vector to align with sun's first child normal to orbit
// vector are local to celestial_frame
sync fn ideal_exposure(vessel: Vessel) -> (exposure: Vec3, normal: Vec3) = {
    const frame = vessel.control_frame

    // OUT: No operational solar panel.
// ksp::console::CONSOLE.print_line("OUT : No operational solar panel.")
    if (!vessel.parts.exists(fn(p) -> p.solar_panel.defined && p.deployable.value.deploy_state == DeployableDeployState.Extended)) // No operational solar panel
        return (exposure: vessel.global_up.to_local(frame), normal: vessel.global_facing.to_local(frame).vector)

    // All solar panels
    const solarPanelParts = vessel.parts
        .filter(fn(p) -> p.solar_panel.defined) // solar panel
        .filter(fn(p) -> p.deployable.value.deploy_state == DeployableDeployState.Extended)

    // Static solar panels
    const staticRotaries = group_statics_as_rotaries(solarPanelParts.filter(fn(p) -> !p.deployable.value.extendable))

    const trueStatic = solarPanelParts.filter(fn(p) -> !p.deployable.value.extendable)
        .filter(fn(ps) -> !staticRotaries.exists(fn(psr_arr) -> psr_arr.exists(fn(psr) -> ps.position == psr.position))) // TODO use part.id when available

    const staticLightVector = trueStatic
        .map(fn(p) -> - p.global_rotation.to_local(frame).right_vector.normalized * p.solar_panel.value.base_flow_rate) // coaxial to light vector, mag = max EC flow
        .reduce(vec3(0.0, 0.0, 0.0), fn(vsum, v) -> vsum + v)

    // Rotary solar panels. Normals to lightplanes are used as definition of planes.
    const lightRotaries = solarPanelParts.filter(fn(p) -> p.deployable.value.extendable)
        .map(fn(p) -> - p.global_rotation.to_local(frame).right_vector.normalized * p.solar_panel.value.base_flow_rate) // normal to light plane, mag = max EC flow
        + enlight_static_as_rotaries(staticRotaries)

    // OUT: No rotary. Process only statics.
// ksp::console::CONSOLE.print_line("OUT : No rotary. Process only statics.")
    if (lightRotaries.length == 0)
        return (exposure: staticLightVector, normal: random_normal(trueStatic))

    const lightPlanes = aggregate_rotaries_as_plane(lightRotaries)

    const intersectCount = (((lightPlanes.length - 1)**2) + (lightPlanes.length - 1)) / 2 // triangular number

    // OUT: Only 1 rotary. Process only statics + the rotary.
// ksp::console::CONSOLE.print_line("OUT : Only 1 rotary. Process only statics + the rotary.")
    if(intersectCount == 0) { // their is at least 1 plane. 0 plane case is already processed
        const rotaryLightVector =
            if(staticLightVector.magnitude > 0.0)
                (staticLightVector - (lightPlanes[Array.First].normalized * lightPlanes[Array.First].dot(staticLightVector))) // rotary light vector oriented mostly at static light vector (projection of static vector on rotary plane)
            else if(lightPlanes[Array.First].dot(vec3(1.0, 0.0, 0.0)) != lightPlanes[0].magnitude)
                lightPlanes[Array.First].cross(vec3(1.0, 0.0, 0.0))
            else
                lightPlanes[Array.First].cross(vec3(0.0, 1.0, 0.0))
        return (exposure: staticLightVector + rotaryLightVector, normal: staticLightVector.exclude_from(lightPlanes[Array.First] + random_normal(trueStatic)))
    }
// ksp::console::CONSOLE.print_line("intersectCount: " + intersectCount.to_string())

    // const intersectPlanes = (0..intersectCount)
    const intersectPlanes = (0..lightPlanes.length)
        .flat_map(fn(i) -> ((i + 1)..lightPlanes.length).map(fn(j) -> lightPlanes[i].cross(lightPlanes[j]).normalized * (lightPlanes[i].magnitude + lightPlanes[j].magnitude)))
        //.flat_map(fn(arr_intersect) -> arr_intersect) // intersect plane is best direction to light both light plane. Sum up all intersect.
        // .reduce(<Vec3>[], fn(flat, arr_intersect) -> flat + arr_intersect) // intersect plane is best direction to light both light plane. Sum up all intersect.
// ksp::console::CONSOLE.print_line("intersectPlanes.lenght: " + intersectPlanes.length.to_string())

    const allLightVector = fasten_sum_unoriented_vectors(intersectPlanes, staticLightVector) + staticLightVector
    const allLightVectorNormal = allLightVector.exclude_from(fasten_sum_unoriented_vectors(lightPlanes, staticLightVector))

    // OUT: All.
// ksp::console::CONSOLE.print_line("OUT : All.")
    (exposure: allLightVector, normal: allLightVectorNormal)
}

// TODO externalize anonym function into named function in order to make code easier to read. As it should be more understandable, get rid of comments.
sync fn group_statics_as_rotaries(staticSolarPanels: Part[]) -> Part[][] = {
    if(staticSolarPanels.length < 2)
        return [<Part>[]]

    const accuracy = 2

    (0..staticSolarPanels.length)
        .flat_map(fn(i) -> ((i + 1)..staticSolarPanels.length).map(fn(j) -> (
            partA: staticSolarPanels[i],
            partB: staticSolarPanels[j],
            normal: (- staticSolarPanels[i].global_rotation.right_vector)
                .cross(- staticSolarPanels[j].global_rotation.right_vector)
                .normalized * (staticSolarPanels[i].solar_panel.value.base_flow_rate + staticSolarPanels[j].solar_panel.value.base_flow_rate))
        ))//.flat_map(fn(arr) -> arr) // record of all parts'pair normal registred in a flat array
        .reduce(<(parts: Part[], normalId: GlobalVector)>[], fn(groups, partPair) -> { // group up parts with same normal
            if(groups.length == Array.Empty) // init
                return [(parts: [partPair.partA, partPair.partB], normalId: partPair.normal)]
            if(groups.exists(fn(g) -> almost_equal_global(g.normalId, partPair.normal, partPair.partA.vessel.control_frame, accuracy))) // grow
                return groups.map(fn(g) -> {
                    if(almost_equal_global(g.normalId, partPair.normal, partPair.partA.vessel.control_frame, accuracy)) { // to group up
                        if(g.parts.exists(fn(p) -> p.position == partPair.partA.position) && (!g.parts.exists(fn(p) -> p.position == partPair.partB.position))) // TODO prefer a part.id than a part.position when it will be available
                            return (parts: g.parts + partPair.partB, normalId: g.normalId)
                        if(g.parts.exists(fn(p) -> p.position == partPair.partB.position) && (!g.parts.exists(fn(p) -> p.position == partPair.partA.position))) // TODO prefer a part.id than a part.position when it will be available
                            return (parts: g.parts + partPair.partA, normalId: g.normalId)
                        return g
                    } else // not concerned
                        g
                })
            groups + (parts: [partPair.partA, partPair.partB], normalId: partPair.normal) // new
        }).map(fn(r) -> r.parts) // get rid of normals
        .filter(fn(a) -> round_at(a.reduce(vec3(0.0, 0.0, 0.0), fn(v, p) -> v + ((- p.global_rotation.to_local(p.vessel.control_frame).right_vector) * p.solar_panel.value.base_flow_rate)).magnitude, accuracy) == 0.0) // keep groups where (sum vec).magnitude == 0.0
        .sort_by(fn(a) -> a.length)
        .reverse()
        .reduce(<Part[]>[], fn(clean, partArr) -> {
            if(clean.length == Array.Empty)
                return clean + partArr
            return clean + partArr.filter(fn(part) -> !clean.flat_map(fn(a) -> a).exists(fn(p) -> p.position == part.position)) // TODO prefer a part.id than a part.position when it will be available
        }) // deduplicate
        .filter(fn(a) -> a.length > Array.Empty) // get rid of possible empties array
}

sync fn enlight_static_as_rotaries(staticSolarPanels: Part[][]) -> Vec3[] =
    staticSolarPanels
        .map(fn(circle) -> {
            const vessel = circle[Array.First].vessel
            const frame = vessel.control_frame
            const accuracy = 2

            const meanFlowRate = (circle.reduce(0.0, fn(sum, p) -> sum + p.solar_panel.value.base_flow_rate) / circle.length.to_float) * (Circle.Quarter / Circle.Full) // ((sum individual flow) / part_number) * mean_exposure

            const legitimAxis = (- circle[Array.First].global_rotation.to_local(frame).right_vector)
                .cross(- circle[circle.length - 1].global_rotation.to_local(frame).right_vector)
                .normalized * meanFlowRate
            if(round_at(legitimAxis.magnitude, accuracy) == 0.0)
                return random_normal(circle)
            legitimAxis
        })

sync fn random_normal(staticSolarPanels: Part[]) -> Vec3 = {
    const staticLightVector = staticSolarPanels
        .map(fn(p) -> - p.global_rotation.to_local(p.vessel.control_frame).right_vector.normalized * p.solar_panel.value.base_flow_rate) // coaxial to light vector, mag = max EC flow
        .reduce(vec3(0.0, 0.0, 0.0), fn(vsum, v) -> vsum + v)
    const staticLightVectorNormalCase0 = staticSolarPanels
        .reduce(vec3(0.0, 0.0, 0.0), fn(sum, p) -> sum + p.global_rotation.to_local(p.vessel.control_frame).up_vector.normalized * p.solar_panel.value.base_flow_rate)
    const staticLightVectorNormalCase1 = staticSolarPanels
        .reduce(vec3(0.0, 0.0, 0.0), fn(sum, p) -> sum + p.global_rotation.to_local(p.vessel.control_frame).vector.normalized * p.solar_panel.value.base_flow_rate)
    staticLightVector.exclude_from(if(staticLightVectorNormalCase0.magnitude > staticLightVectorNormalCase1.magnitude) staticLightVectorNormalCase0 else staticLightVectorNormalCase1)
}

// sum parallels planes
sync fn aggregate_rotaries_as_plane(lightRotaries: Vec3[]) -> Vec3[] =
    lightRotaries.reduce(<Vec3>[], fn(notParallel, normal) -> {
        if(!notParallel.exists(fn(np) -> round_at(np.normalized.cross(normal.normalized).magnitude, 2) == 0.0)) // empty or not parallel
            return notParallel + normal
        return notParallel.map(fn(np) -> {
            if(round_at(np.cross(normal).magnitude, 1) == 0.0) // sum up all parallel planes
                np + (np.normalized.dot(normal.normalized) * normal) // force normal to be in the same direction than np
            else
                np
        })
    })


sync fn fasten_sum_unoriented_vectors(unorientedVectors: Vec3[], reference: Vec3) -> Vec3 =
    unorientedVectors.reduce(vec3(0.0, 0.0, 0.0), fn(vsum, v) -> {
        if(round_at(reference.normalized.dot(v.normalized), 1) != 0.0) // mostly in direction of reference, if any
            vsum + (v * (reference.normalized.dot(v.normalized)))
        else
            vsum + v
    })

// if(round_at(abs(g.normalId.dot(partPair.normal)), precision) == round_at(abs(g.normalId.magnitude * partPair.normal.magnitude), precision)) {
// if(round_at(abs(g.normalId.cross(partPair.normal).magnitude), precision) == 0.0 && round_at(g.normalId.magnitude, precision) == round_at(partPair.normal.magnitude, precision) && partPair.partA.part_name == partPair.partB.part_name && (
//     round_at(partPair.partA.global_position.to_local(partPair.partA.vessel.control_frame).x, precision) == round_at(partPair.partB.global_position.to_local(partPair.partB.vessel.control_frame).x, precision)
//     || round_at(partPair.partA.global_position.to_local(partPair.partA.vessel.control_frame).y, precision) == round_at(partPair.partB.global_position.to_local(partPair.partB.vessel.control_frame).y, precision)
//     || round_at(partPair.partA.global_position.to_local(partPair.partA.vessel.control_frame).z, precision) == round_at(partPair.partB.global_position.to_local(partPair.partB.vessel.control_frame).z, precision)
//     )) {