use { AutopilotMode } from ksp::vessel
use { RAD_TO_DEG, abs, max, clamp, atan2_deg, cos_deg, sin_deg, log, round } from core::math
use { Direction } from ksp::math
use { current_time, yield, wait_until } from ksp::game

use { Apsis, ApsisConst, ApsisModification, ApsisModificationConst } from maneuver::constant
use { Throttle, ThrustSituation } from ship::constant
use { Circle, Sexagesimal, Array } from math::constant
use { Ship } from ship::ship
use { visViva, semi_major_axis, semi_minor_axis, param_deltaV, eta_trueAnomaly, prograde_elevation, radius_true_anomaly } from body::orbit
use { atmosphere_depth } from body::atmosphere
use { burntime, compassFromOrbit, compassFromDirection, inertia } from ship::navigation
use { significant_digit } from math::rounding
use { engineeringNotation } from ui::unit


// const MIN_BURNTIME: float = 5.0 // ok 80km
// const MIN_BURNTIME: float = 10.0 // ok 200 km
// const MIN_BURNTIME: float = 7.0 // ok 200 km
// const MIN_BURNTIME: float = 6.0 // ok 200 km
// const MIN_BURNTIME: float = 15.0 // ok 2000km
// const MIN_BURNTIME: float = 12.0 // ok 2000km
// const MIN_BURNTIME: float = 10.0 // ko 2000km
// const MIN_BURNTIME: float = 100.0 // ok but verylong for 2000km


// const MIN_BURNTIME: float = 3.0 //eq dep
const MIN_BURNTIME: float = 5.0 //eq dep

pub fn circularize(ship: Ship, way: ApsisModificationConst = ApsisModification.Cheaper) -> Result<Unit, string> = {
    const vessel = ship.ship
    const body = vessel.main_body

    if(ship.periapsis() < atmosphere_depth(body) && (!vessel.orbit.apoapsis.defined))
        return Err("Unable to circularize " + vessel.name)
    if(ship.periapsis() < atmosphere_depth(body) && way == ApsisModification.Decrease)
        return Err("Unable to circularize " + vessel.name + " at " + engineeringNotation(ship.periapsis()) + "m because it's below " + vessel.main_body.name + "'s atmosphere.")
    if((!vessel.orbit.apoapsis.defined) && way == ApsisModification.Raise)
        return Err("Unable to circularize " + vessel.name + " at apoapsis because of hyperbolic orbit (escape " + vessel.main_body.name + "'s sphere of influence)")

    if(way == ApsisModification.Raise)
        return set_apsis_fine(ship, Apsis.Periapsis, ship.apoapsis())
    else if(way == ApsisModification.Decrease)
        return set_apsis_fine(ship, Apsis.Apoapsis, ship.periapsis())

    if(ship.periapsis() < atmosphere_depth(body))
        return set_apsis_fine(ship, Apsis.Periapsis, ship.apoapsis())
    if((!vessel.orbit.apoapsis.defined))
        return set_apsis_fine(ship, Apsis.Apoapsis, ship.periapsis())

    const deltaVRise = param_deltaV(
        vessel.orbit,
        semi_major_axis(body, ship.apoapsis(), ship.apoapsis()),
        vessel.orbit.inclination,
        ship.apoapsis(),
        ship.apoapsis()
    )
    const deltaVDecrease = param_deltaV(
        vessel.orbit,
        semi_major_axis(body, ship.periapsis(), ship.periapsis()),
        vessel.orbit.inclination,
        ship.periapsis(),
        ship.periapsis()
    )

    if(deltaVDecrease < deltaVRise)
        return set_apsis_fine(ship, Apsis.Apoapsis, ship.periapsis())
    return set_apsis_fine(ship, Apsis.Periapsis, ship.apoapsis())
}


sync fn direction_manager(ship: Ship, thrustTrueAno: float, thrustOrientation: ApsisModificationConst, error: float) -> Direction = {
    const vessel = ship.ship

    const vesselTrueAno = vessel.orbit.true_anomaly_from_vector(vessel.position) * RAD_TO_DEG
    const thrustElevation = prograde_elevation(thrustTrueAno, vessel.orbit.semi_major_axis, semi_minor_axis(vessel.orbit.semi_major_axis, vessel.orbit.eccentricity))

    const sma = semi_major_axis(vessel.main_body, ship.periapsis(), ship.apoapsis())
    const smi = semi_minor_axis(sma, vessel.orbit.eccentricity)
    const radiusAltTA = radius_true_anomaly(vesselTrueAno, sma , smi)
    const y = (max(log(sma), 1) + 1) * error + 1
    const x = radiusAltTA * sin_deg(thrustTrueAno - vesselTrueAno)
    // const elevationCorrector = atan2_deg(y, x)
    const elevationCorrector = atan2_deg(y * sma, x * smi)

    const elevation = thrustElevation - (thrustTrueAno - vesselTrueAno) + thrustOrientation + elevationCorrector

    const azimuth = compassFromDirection(vessel, ship.prograde())

// ksp::console::CONSOLE.print_at(12, 50, "ThTa".pad_right(7) + " : " + thrustTrueAno.to_fixed(2).pad_left(6))
// ksp::console::CONSOLE.print_at(12, 70, "vesTa".pad_right(7) + " : " + vesselTrueAno.to_fixed(2).pad_left(6))
// ksp::console::CONSOLE.print_at(13, 50, "ThEl".pad_right(7) + " : " + thrustElevation.to_fixed(2).pad_left(6))
// ksp::console::CONSOLE.print_at(13, 70, "ThOr".pad_right(7) + " : " + thrustOrientation.to_fixed(2).pad_left(6))
// ksp::console::CONSOLE.print_at(14, 50, "az".pad_right(7) + " : " + azimuth.to_fixed(2).pad_left(6))
// ksp::console::CONSOLE.print_at(14, 70, "el".pad_right(7) + " : " + elevation.to_fixed(2).pad_left(6))
// ksp::console::CONSOLE.print_at(30, 50, "elCorr".pad_right(7) + " : " + elevationCorrector.to_string().pad_left(6))

    return vessel.heading_direction(azimuth, elevation, 0.0)
}


sync fn controleThrottle(ship: Ship, altitude: float, burntime: float, thrustTrueAno: float, thrustDirection: Direction) -> float = {
    const vessel = ship.ship

    const etaThrust = eta_trueAnomaly(vessel.orbit, thrustTrueAno)


// TODO current : time to react = 1 second. Add parametrizable time to react (fn weight ?)
// note eccentricity have influence on MIN_BURNTIME
// TODO MIN_BURNTIME should be fn alt
// TODO constant speed of light in vacuum = 299792458
// ksp::console::CONSOLE.print_at(1, 50, "mass: " + ship.mass().to_string())
// ksp::console::CONSOLE.print_at(2, 50, "inertia: " + (ship.mass()/core::math::sqrt(1 - ((vessel.orbital_velocity.magnitude**2)/(299792458**2)))).to_string())
// ksp::console::CONSOLE.print_at(3, 50, "Alt: " + altitude.to_string())
    // base
    // const throttleTime =
    //     if (burntime < 1 && etaThrust > 0)
    //         clamp((burntime - etaThrust + MIN_BURNTIME) * burntime, Throttle.Shut, Throttle.Max)
    //     else if (burntime > 1)
    //         clamp(burntime - etaThrust + MIN_BURNTIME, Throttle.Shut, Throttle.Max)
    //     else
    //         Throttle.Shut

    const reactionTime = fn() -> ship.twr()/ship::constant::Twr.Ideal

    // not bad
    const throttleTime =
        if (burntime < 1 && etaThrust > 0)
            clamp((burntime - etaThrust + core::math::max(MIN_BURNTIME, reactionTime() + inertia(ship))) * burntime, Throttle.Min, Throttle.Max)
        else if (burntime > 1)
            clamp((burntime - etaThrust + core::math::max(MIN_BURNTIME, reactionTime() + inertia(ship)) ) / reactionTime(), Throttle.Shut, Throttle.Max)
        else
            Throttle.Shut

    // Meh
    // const throttleTime =
    //     if (etaThrust > 0)
    //         clamp((burntime - etaThrust + core::math::max(MIN_BURNTIME, reactionTime + inertia()) ) / reactionTime, Throttle.Shut, Throttle.Max)
    //     else
    //         Throttle.Shut


    const maxAllowedThrottle = [throttleTime, ship.throttle_temperature(), ship.throttle_q(), ship.throttle_altitude(altitude)]
        .sort()[Array.First]

// ksp::console::CONSOLE.print_at(9, 50, "ttTi ttTe ttQ ttAl ttDi")
// ksp::console::CONSOLE.print_at(10, 50, throttleTime.to_fixed(2))
// ksp::console::CONSOLE.print_at(10, 55, ship.throttle_temperature().to_fixed(2))
// ksp::console::CONSOLE.print_at(10, 60, ship.throttle_q().to_fixed(2))
// ksp::console::CONSOLE.print_at(10, 65, ship.throttle_altitude(altitude).to_fixed(2))
// ksp::console::CONSOLE.print_at(10, 70, ship.throttle_direction(thrustDirection, 1.0, 1.0).to_fixed(2))

// ksp::console::CONSOLE.print_at(16, 50, "etaTh".pad_right(7) + " : " + etaThrust.to_fixed(2).pad_left(6))
// ksp::console::CONSOLE.print_at(16, 70, "refEta".pad_right(7) + " : " + etaThrust.to_fixed(2).pad_left(6))
// ksp::console::CONSOLE.print_at(17, 50, "bt".pad_right(7) + " : " + burntime.to_fixed(2).pad_left(6))
// ksp::console::CONSOLE.print_at(17, 70, "etaBt".pad_right(7) + " : " + (etaThrust - burntime - MIN_BURNTIME).to_fixed(2).pad_left(6))
// ksp::console::CONSOLE.print_at(18, 70, "TttT".pad_right(7) + " : " + throttleTime.to_fixed(2).pad_left(6))

    const errorModeratorThrottle = ship.throttle_direction(thrustDirection, 1.0, 1.0)

    return maxAllowedThrottle * errorModeratorThrottle
}

pub fn set_apsis_fine(ship: Ship, apsis: ApsisConst, altitude:float) -> Result<Unit, string> = {
    const vessel = ship.ship
    const body = vessel.main_body
    const accuracy = 7

    const initialArgOfPeriapsis = vessel.orbit.argument_of_periapsis

    const selector = fn(a: fn() -> float, p: fn() -> float) -> {
        if(apsis == Apsis.Periapsis)
            if(abs(initialArgOfPeriapsis - vessel.orbit.argument_of_periapsis) < Circle.Quarter) p else a
        else
            if(abs(initialArgOfPeriapsis - vessel.orbit.argument_of_periapsis) < Circle.Quarter) a else p
    }

    const toSetApsis = selector(ship.apoapsis, ship.periapsis)
    const toKeepApsis = selector(ship.periapsis, ship.apoapsis)
    const staticApsis = toKeepApsis()

    const thrustTrueAno = selector(fn() -> {Circle.None}, fn() -> {Circle.Semi})
    const thrustOrientation = if(toSetApsis() < altitude) ApsisModification.Raise else ApsisModification.Decrease

    const deltaVLeft = fn() -> param_deltaV(vessel.orbit, semi_major_axis(body, toKeepApsis(), altitude), vessel.orbit.inclination, toKeepApsis(), toKeepApsis())

//TODO not only round, but use only significant digit
    // const done = fn() -> { // round_at(x, 5) ?
    //     if(round(staticApsis) == round(altitude))
    //         return round(toKeepApsis()) == round(toSetApsis())
    //     if(thrustOrientation == ApsisModification.Raise) (round(toSetApsis()) >= round(altitude)) (round(toSetApsis()) <= round(altitude))
    // }
    const done = fn() -> {
        if(round(significant_digit(staticApsis, accuracy)) == round(significant_digit(altitude, accuracy)))
            return round(significant_digit(toKeepApsis(), accuracy)) == round(significant_digit(toSetApsis(), accuracy))
        if(thrustOrientation == ApsisModification.Raise) (round(significant_digit(toSetApsis(), accuracy)) >= round(significant_digit(altitude, accuracy))) else (round(significant_digit(toSetApsis(), accuracy)) <= round(significant_digit(altitude, accuracy)))
    }

    ship.set_throttle_altitude(altitude, MIN_BURNTIME / 3)
    const tmanager = vessel.manage_throttle(fn(altitude) -> controleThrottle(
        ship,
        toSetApsis(),
        burntime(ship, deltaVLeft()),
        thrustTrueAno(),
        direction_manager(ship, thrustTrueAno(), thrustOrientation, staticApsis - toKeepApsis())
    ))

    while(!done()) {
        yield()
        ship.check_staging()
        ship.check_jettison()
        ship.check_deploy()
        ship.check_science()


        ship.point_to_onthefly(direction_manager(ship, thrustTrueAno(), thrustOrientation, staticApsis - toKeepApsis()).vector)
        // // Enable SAS
        // if(vessel.autopilot.enabled != true || vessel.autopilot.mode != AutopilotMode.Autopilot) {
        //     vessel.autopilot.enabled = true
        //     vessel.autopilot.mode = AutopilotMode.Autopilot
        // }
        // vessel.autopilot.target_orientation = direction_manager(ship, thrustTrueAno(), thrustOrientation, staticApsis - toKeepApsis()).vector

        if (ship.deltaV() < 1)
            return Err("Not enought fuel to reach a " + engineeringNotation(altitude) + "m. " + (if(apsis == Apsis.Periapsis) "periapsis" else "apoapsis") + " above " + body.name)

// ksp::console::CONSOLE.print_at(18, 50, "dvleft".pad_right(7) + " : " + deltaVLeft().to_fixed(2).pad_left(6))
// body::debug::orbit_debug(vessel, vessel.orbit)

// ksp::console::CONSOLE.print_at(20, 50, "tsa".pad_right(7) + " : " + toSetApsis().to_fixed(2).pad_left(6))
// ksp::console::CONSOLE.print_at(20, 70, "tka".pad_right(7) + " : " + toKeepApsis().to_fixed(2).pad_left(6))
// ksp::console::CONSOLE.print_at(21, 50, "ori".pad_right(7) + " : " + thrustOrientation.to_fixed(2).pad_left(6))
// ksp::console::CONSOLE.print_at(21, 70, "done".pad_right(7) + " : " + done().to_string().pad_left(6))
// ksp::console::CONSOLE.print_at(28, 50, "sa".pad_right(7) + " : " + staticApsis.to_fixed(2).pad_left(6))
// ksp::console::CONSOLE.print_at(28, 70, "aim".pad_right(7) + " : " + altitude.to_fixed(2).pad_left(6))

    }
    vessel.set_throttle(0.0)
    wait_until(fn() -> (ship.thrust(ThrustSituation.Current) == 0.0))
    vessel.release_control()
    // tmanager.release()
    ship.print_status()
}